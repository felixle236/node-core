import { {PascalName} } from 'domain/entities/{folder}/{PascalName}';
import { I{PascalName}Repository } from 'application/interfaces/repositories/{folder}/I{PascalName}Repository';
import { InjectRepository } from 'shared/types/Injection';
import { Service } from 'typedi';
import { Repository } from '../../common/Repository';
import { {PascalName}Db } from '../../entities/{folder}/{PascalName}Db';
import { {UPPER_CASE_NAME}_SCHEMA } from '../../schemas/{folder}/{PascalName}Schema';

@Service(InjectRepository.{PascalName})
export class {PascalName}Repository extends Repository<{PascalName}, {PascalName}Db> implements I{PascalName}Repository {
    constructor() {
        super({PascalName}Db, {UPPER_CASE_NAME}_SCHEMA);
    }

    override async findAndCount(filter: { keyword?: string, skip: number, limit: number }): Promise<[{PascalName}[], number]> {
        let query = this.repository.createQueryBuilder({UPPER_CASE_NAME}_SCHEMA.TABLE_NAME);

        if (filter.keyword) {
            const keyword = `%${filter.keyword}%`;
            query = query.andWhere(`${{UPPER_CASE_NAME}_SCHEMA.TABLE_NAME}.${{UPPER_CASE_NAME}_SCHEMA.COLUMNS.NAME} ILIKE :keyword`, { keyword });
        }
        query.skip(filter.skip).take(filter.limit);

        const [list, count] = await query.getManyAndCount();
        return [list.map(item => item.toEntity()), count];
    }

    async checkNameExist(name: string, excludeId?: string): Promise<boolean> {
        let query = this.repository.createQueryBuilder({UPPER_CASE_NAME}_SCHEMA.TABLE_NAME)
            .where(`lower(${{UPPER_CASE_NAME}_SCHEMA.TABLE_NAME}.${{UPPER_CASE_NAME}_SCHEMA.COLUMNS.NAME}) = lower(:name)`, { name });

        if (excludeId)
            query = query.andWhere(`${{UPPER_CASE_NAME}_SCHEMA.TABLE_NAME}.${{UPPER_CASE_NAME}_SCHEMA.COLUMNS.ID} != :id`, { id: excludeId });

        const result = await query.getOne();
        return !!result;
    }
}
