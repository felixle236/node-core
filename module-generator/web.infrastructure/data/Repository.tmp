import { mapModel, mapModels } from '../../../../libs/common';
import { {PascalName} } from '../../../../web.core/models/{PascalName}';
import { {PascalName}CreateData } from '../../../../web.core/dtos/{camelName}/data/{PascalName}CreateData';
import { {PascalName}Entity } from '../entities/{PascalName}Entity';
import { {PascalName}FilterRequest } from '../../../../web.core/dtos/{camelName}/requests/{PascalName}FilterRequest';
import { {PascalName}Schema } from '../schemas/{PascalName}Schema';
import { {PascalName}UpdateData } from '../../../../web.core/dtos/{camelName}/data/{PascalName}UpdateData';
import { I{PascalName} } from '../../../../web.core/gateways/models/I{PascalName}';
import { I{PascalName}Repository } from '../../../../web.core/gateways/gateways/data/I{PascalName}Repository';
import { Service } from 'typedi';
import { SortType } from '../../../../constants/Enums';
import { getRepository } from 'typeorm';

@Service('{camelName}.repository')
export class {PascalName}Repository implements I{PascalName}Repository {
    private readonly _repository = getRepository<I{PascalName}>({PascalName}Entity);

    async find(filter: {PascalName}FilterRequest): Promise<[{PascalName}[], number]> {
        let query = this._repository.createQueryBuilder({PascalName}Schema.TABLE_NAME)
            .where(`${{PascalName}Schema.TABLE_NAME}.${{PascalName}Schema.COLUMNS.DELETED_AT} IS ${filter.isDeleted ? 'NOT' : ''} NULL`);

        if (filter.keyword) {
            const keyword = `%${filter.keyword}%`;
            query = query.andWhere(`${{PascalName}Schema.TABLE_NAME}.${{PascalName}Schema.COLUMNS.NAME} ilike :keyword`, { keyword });
        }

        query = query
            .orderBy(`${{PascalName}Schema.TABLE_NAME}.${{PascalName}Schema.COLUMNS.NAME}`, SortType.ASC)
            .skip(filter.skip)
            .take(filter.limit);

        const [list, count] = await query.getManyAndCount();
        return [mapModels({PascalName}, list), count];
    }

    async getById(id: number): Promise<{PascalName} | undefined> {
        const data = await this._repository.createQueryBuilder({PascalName}Schema.TABLE_NAME)
            .whereInIds(id)
            .getOne();
        return mapModel({PascalName}, data);
    }

    async checkNameExist(name: string, excludeId?: number): Promise<boolean> {
        let query = this._repository.createQueryBuilder({PascalName}Schema.TABLE_NAME)
            .where(`lower(${{PascalName}Schema.TABLE_NAME}.${{PascalName}Schema.COLUMNS.NAME}) = lower(:name)`, { name });

        if (excludeId)
            query = query.andWhere(`${{PascalName}Schema.TABLE_NAME}.${{PascalName}Schema.COLUMNS.ID} != :id`, { id: excludeId });

        const {camelName} = await query.getOne();
        return !!{camelName};
    }

    async create(data: {PascalName}CreateData): Promise<number | undefined> {
        const result = await this._repository.createQueryBuilder({PascalName}Schema.TABLE_NAME)
            .insert()
            .values(data)
            .execute();
        return result.identifiers && result.identifiers.length && result.identifiers[0].id;
    }

    async update(id: number, data: {PascalName}UpdateData): Promise<boolean> {
        const result = await this._repository.createQueryBuilder({PascalName}Schema.TABLE_NAME)
            .update(data)
            .whereInIds(id)
            .execute();
        return !!result.affected;
    }

    async delete(id: number): Promise<boolean> {
        const result = await this._repository.createQueryBuilder({PascalName}Schema.TABLE_NAME)
            .softDelete()
            .whereInIds(id)
            .execute();
        return !!result.affected;
    }
}
